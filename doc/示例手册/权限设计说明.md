# RBAC
> Role-Based Access Control
> 一种基于角色的权限访问控制。原则上所有的功能权限以及菜单权限都是基于角色来授权，避免直接给予用户授权。

### RBAC的优点
> 简化了用户和权限的关系，实现用户和资源的分离，后期分配和回收权限都会很方便。


### RBAC支持的安全原则
> RBAC支持三个著名的安全原则：最小权限原则、责任分离原则、数据抽象原则

* 最小权限原则：RBAC可以将角色配置成其完成任务所需的最小权限集合
* 责任分离原则：可以通过调用相互独立互斥的角色来共同完成敏感的任务，例如要求一个计账员和财务管理员共同参与统一过账操作
* 数据抽象原则：可以通过权限的抽象来体现，例如财务操作用借款、存款等抽象权限，而不是使用典型的读、写、执行权限

#### RBAC模块功能
> 用户管理
* 用户列表、添加用户、编辑用户、设置角色
> 角色管理
* 角色列表、添加角色、编辑角色、设置权限
> 权限管理
* 权限列表、添加权限、编辑权限

#### RBAC数据库表设计
* ins_user 用户表
* ins_user_role 用户角色关联
* ins_role 角色表（role_type: O:组织角色, T:职称角色）
* ins_func_role 角色权限关联
* sys_func 权限表（type：'0' 菜单权限，'M' 操作权限）
* sys_menu 菜单表       
* ins_menu_role 角色菜单关联
* ins_func_temp 临时操作权限表（失效后会自动清理）
* ins_menu_temp 临时菜单权限表（失效后会自动清理）
* ins_user_func 是老表，需要做权限收敛，以后废弃不用了。
* ins_role_mapping 岗位 + 部门 到 角色的映射关系表
```sql
                               ins_user
                                  |
       ins_func_temp         ins_user_role      ins_menu_temp
                                  |
sys_func  -  ins_func_role  -  ins_role  -  ins_menu_role  -  sys_menu

```

#### 临时权限如何分配
* 临时菜单权限配置在 ins_menu_temp 中，
* 临时操作权限配置在 ins_func_temp 中
* 过期时间配置要求：now() < expire_date < now() + INTERVAL 30 DAY
* 后台定时任务，会定期将过期的、异常的临时操作权限、菜单权限清除，确保权限数据的干净。

#### 登录步骤说明
* 根据 username 查 ins_user 表，获取用户的基本信息。
* 根据 user_id 查 ins_user_role 表, 获取用户有哪些角色。
* 根据 user_id 查 ins_func_temp 表，获取用户临时操作权限。
* 根据 user_id 查 ins_menu_temp 表，获取用户临时菜单权限。
* 根据 role_id 查 ins_func_role 表, 获取用户有哪些操作权限。
* 根据 role_id 查 ins_menu_role 表，获取用户有哪些菜单权限。

#### 获取登录上下文:
```java
UserContext userContext = WebContextUtils.getUserContext();
userContext.getMobileNo(); // 手机号码
userContext.getUsername(); // 用户名
userContext.getUserId();   // 用户ID
userContext.getRoles();    // 用户角色
Collection<GrantedAuthority> grantedAuthorities = userContext.getGrantedAuthorities();
grantedAuthorities.forEach(System.out::println); // 获取功能权限
```

#### 菜单授权:
* 只需对叶子菜单进去授权，系统会将叶子菜单的所有上级目录展示出来。
* 菜单授权基于角色表来进行。

### 基于注解的权限验证
#### 源码重点: SecurityExpressionRoot.java
开启支持：
```java
@EnableGlobalMethodSecurity(prePostEnabled = true)
public class WebSecurityConfig extends WebSecurityConfigurerAdapter {
    
}
```

```java
// 确保有 A 角色，才可执行
@PreAuthorize("hasRole('A')")

// 确保有 A 或 B 角色，才可执行
@PreAuthorize("hasAnyRole('A','B')")

// 确保有 P1 操作权限，才可执行
@PreAuthorize("hasAuthority('P1')")

// 确保有 P1 或 P2 操作权限，才可执行
@PreAuthorize("hasAnyAuthority('P1', 'P2')")
```

#### 拥有某个角色
```java
@RequestMapping(value = "/setting/username", method = RequestMethod.POST)    
@PreAuthorize("hasRole('ROOT')")
@ResponseBody
public Map<String, String> userName(User user, @RequestParam(value = "username") String username) {
    Map<String, String> modelMap = new HashMap<String, String>();
    System.out.println(username);

    user.setUsername(username);
    userService.update(user);
    
    modelMap.put("status", "ok");
    return modelMap;
}
```

#### 拥有某个操作权限
```java
@RequestMapping(value = "/setting/username", method = RequestMethod.POST)    
@PreAuthorize("hasAuthority('ROOT')")
@ResponseBody
public Map<String, String> userName(User user, @RequestParam(value = "username") String username) {
    Map<String, String> modelMap = new HashMap<String, String>();
    System.out.println(username);

    user.setUsername(username);
    userService.update(user);
    
    modelMap.put("status", "ok");
    return modelMap;
}
```

#### 岗位 + 部门 => 角色
CREATE TABLE `ins_role_mapping`
(
    `id`             bigint(20) unsigned NOT NULL AUTO_INCREMENT,
    `org_id`         bigint(20) unsigned NOT NULL COMMENT '部门Id，对应 ins_org.org_id',
    `job_role`       varchar(100)        NOT NULL COMMENT '岗位，对应 code_value, select * from sys_static_data t where t.code_type="JOB_ROLE"',
    `role_id`        bigint(20) unsigned NOT NULL COMMENT '角色Id，对应 ins_role.role_id',
    `is_enabled`     tinyint(1) unsigned NOT NULL COMMENT '1：有效数据，0：无效数据',
    PRIMARY KEY (`id`),
    KEY `idx_map` (`org_id`, `job_role`, `is_enabled`)
) ENGINE = InnoDB
  AUTO_INCREMENT = 1
  DEFAULT CHARSET = utf8;